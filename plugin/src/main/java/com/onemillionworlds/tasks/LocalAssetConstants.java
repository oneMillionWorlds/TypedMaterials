package com.onemillionworlds.tasks;

import org.gradle.api.DefaultTask;
import org.gradle.api.Project;
import org.gradle.api.file.FileCollection;
import org.gradle.api.tasks.Input;
import org.gradle.api.tasks.InputFiles;
import org.gradle.api.tasks.OutputFile;
import org.gradle.api.tasks.SourceSet;
import org.gradle.api.tasks.SourceSetContainer;
import org.gradle.api.tasks.TaskAction;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class LocalAssetConstants extends DefaultTask{

    private static final String classTemplate = """
                                     package [PACKAGE];
                                     
                                     /**
                                      * AUTOGENERATED CLASS, do not modify
                                      * <p>
                                      * Generated by the Typed Materials plugin. For more information:
                                      * </p>
                                      * @see <a href="https://github.com/oneMillionWorlds/TypedMaterials/wiki">MaterialTyper Plugin Wiki</a>
                                      */
                                     @SuppressWarnings("all")
                                     public class [CLASS] {
                                     
                                     [CONTENT]
                                     
                                     }""";

    String fullyQualifiedAssetsClass;

    File outputSourcesRoot;

    @TaskAction
    public void createTypedMaterials() throws IOException{
        AssetsFolder assetsFolder = new AssetsFolder("");

        for(File folder : getFileCollectionFromSourceDirs()){
            assetsFolder.addAll(searchForAllFiles(folder, ""));
        }

        String classContent = assetsFolder.getJavaClassContent(1);

        String fullClass = classTemplate
                .replace("[PACKAGE]", getDestinationPackage())
                .replace("[CLASS]", getClassName())
                .replace("[CONTENT]", classContent);

        try {
            Files.writeString(getDestinationFile().toPath(), fullClass);
        } catch (Exception e) {
            throw new RuntimeException("Error writing record of generation: " + getName() + ". " + e.getMessage(), e);
        }
    }

    private AssetsFolder searchForAllFiles(File file, String currentPath) throws IOException{

        AssetsFolder assetsFolder = new AssetsFolder(currentPath);

        for( File fileToProcess : Arrays.stream(file.listFiles()).sorted().toList()){
            if (fileToProcess.isFile()){
                assetsFolder.addAsset(fileToProcess.getName());
            }else{
                AssetsFolder subFolder = searchForAllFiles(fileToProcess, currentPath + (currentPath.isBlank()?"":"/") + fileToProcess.getName());
                assetsFolder.addSubfolder(fileToProcess.getName(), subFolder);
            }
        }

        return assetsFolder;
    }

    @Input
    public String getFullyQualifiedAssetsClass(){
        return fullyQualifiedAssetsClass;
    }

    /*
    @InputFiles
    public Collection<File> getFoldersToProcess(){
        SourceSetContainer sourceSets = (SourceSetContainer) getProject().getProperties().get("sourceSets");
        SourceSet mainSourceSet = sourceSets.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
        return mainSourceSet.getResources().getSrcDirs();
    }*/

    @InputFiles
    public FileCollection getFileCollectionFromSourceDirs() {
        Project project = getProject();
        SourceSetContainer sourceSets = (SourceSetContainer) project.getProperties().get("sourceSets");
        SourceSet mainSourceSet = sourceSets.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
        return project.files(mainSourceSet.getResources().getSrcDirs());
    }

    @OutputFile
    public File getDestinationFile(){
        return new File(outputSourcesRoot, fullyQualifiedAssetsClass.replace(".", "/") + ".java");
    }

    public void setOutputSourcesRoot(File outputSourcesRoot){
        this.outputSourcesRoot = outputSourcesRoot;
    }

    public void setFullyQualifiedAssetsClass(String fullyQualifiedAssetsClass){
        this.fullyQualifiedAssetsClass = fullyQualifiedAssetsClass;
    }

    private String getDestinationPackage(){
        return fullyQualifiedAssetsClass
                .replaceAll("\\.[A-Za-z0-9_]+$", "");
    }

    private String getClassName(){
        return fullyQualifiedAssetsClass
                .replaceAll(".*\\.", "");
    }


    private static class AssetsFolder{
        String assetFolderPath;

        Map<String, AssetsFolder> subfolders = new LinkedHashMap<>();

        List<String> assetsOnThisLevel = new ArrayList<>();

        public AssetsFolder(String assetFolderPath){
            this.assetFolderPath = assetFolderPath;
        }

        public String getJavaClassContent(int indentLevel){
            StringBuilder content = new StringBuilder();

            Set<String> usedSimpleNames = new HashSet<>();

            for(String asset : assetsOnThisLevel){
                String complexName = toUpperSnakeCase(makeValidJavaIdentifier(asset));
                String simpleName = toUpperSnakeCase(makeValidJavaIdentifier(asset.replaceAll("\\..*", "")));
                String nameToUse;
                if (!usedSimpleNames.contains(simpleName)){
                    nameToUse = simpleName;
                    usedSimpleNames.add(simpleName);
                }else{
                    nameToUse = complexName;
                }

                content
                        .append(" ".repeat(indentLevel*4))
                        .append("public static final String ").append(nameToUse)
                        .append(" = \"").append(assetFolderPath + "/"+asset).append("\";\n");
            }

            for(Map.Entry<String, AssetsFolder> subfolder : subfolders.entrySet()){
                content
                        .append(" ".repeat(indentLevel*4))
                        .append("public static class ").append(makeValidJavaClass(subfolder.getKey()))
                        .append("{\n")
                        .append(subfolder.getValue().getJavaClassContent(indentLevel+1))
                        .append(" ".repeat(indentLevel*4))
                        .append("}\n");
            }
            return content.toString();
        }

        public void addAsset(String asset){
            assetsOnThisLevel.add(asset);
        }

        public void addSubfolder(String subfolder, AssetsFolder assetsFolder){
            subfolders.put(subfolder, assetsFolder);
        }

        private String makeValidJavaClass(String name){
            String validIdentifier = makeValidJavaIdentifier(name);
            return validIdentifier.substring(0, 1).toUpperCase() + validIdentifier.substring(1);
        }

        private String makeValidJavaIdentifier(String name){
            String corrected = name.replaceAll("[^a-zA-Z0-9]", "_");

            if (Character.isDigit(corrected.charAt(0))){
                corrected = "_" + corrected;
            }
            return corrected;
        }

        private String toUpperSnakeCase(String name){
            return name.replaceAll("([a-z])([A-Z])", "$1_$2").toUpperCase();
        }

        public void addAll(AssetsFolder assetsFolder){
            assetsOnThisLevel.addAll(assetsFolder.assetsOnThisLevel);
            for(Map.Entry<String, AssetsFolder> subfolder : assetsFolder.subfolders.entrySet()){
                if (subfolders.containsKey(subfolder.getKey())){
                    subfolders.get(subfolder.getKey()).addAll(subfolder.getValue());
                }else{
                    subfolders.put(subfolder.getKey(), subfolder.getValue());
                }
            }
        }
    }

}
