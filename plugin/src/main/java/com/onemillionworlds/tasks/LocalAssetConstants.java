package com.onemillionworlds.tasks;

import org.gradle.api.DefaultTask;
import org.gradle.api.tasks.Input;
import org.gradle.api.tasks.InputDirectory;
import org.gradle.api.tasks.OutputFile;
import org.gradle.api.tasks.TaskAction;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class LocalAssetConstants extends DefaultTask{

    private static final String classTemplate = """
                                     package [PACKAGE];
                                     
                                     /**
                                      * AUTOGENERATED CLASS, do not modify
                                      * <p>
                                      * Generated by the MaterialTyper plugin. For more information:
                                      * </p>
                                      * @see <a href="https://github.com/oneMillionWorlds/TypedMaterials/wiki">MaterialTyper Plugin Wiki</a>
                                      */
                                     @SuppressWarnings("all")
                                     public class Assets {
                                     
                                     [CONTENT]
                                     
                                     }""";

    File assetsFolder;

    String outputPackage;

    File outputSourcesRoot;

    String resourcesDirName = "resources";

    @TaskAction
    public void createTypedMaterials() throws IOException{
        String classContent = searchForAllMaterials(assetsFolder, "").getJavaClassContent(1);

        String fullClass = classTemplate
                .replace("[PACKAGE]", outputPackage)
                .replace("[CONTENT]", classContent);

        try {
            Files.writeString(getDestinationFile().toPath(), fullClass);
        } catch (Exception e) {
            throw new RuntimeException("Error writing record of generation: " + getName() + ". " + e.getMessage(), e);
        }
    }

    private AssetsFolder searchForAllMaterials(File file, String currentPath) throws IOException{

        AssetsFolder assetsFolder = new AssetsFolder(currentPath);

        for( File fileToProcess : Arrays.stream(file.listFiles()).sorted().toList()){
            if (fileToProcess.isFile()){
                assetsFolder.addAsset(fileToProcess.getName());
            }else{
                AssetsFolder subFolder = searchForAllMaterials(fileToProcess, currentPath + (currentPath.isBlank()?"":"/") + fileToProcess.getName());
                assetsFolder.addSubfolder(fileToProcess.getName(), subFolder);
            }
        }

        return assetsFolder;
    }

    @Input
    public String getOutputPackage(){
        return outputPackage;
    }

    @InputDirectory
    public File getAssetsFolder(){
        return assetsFolder;
    }

    @OutputFile
    public File getDestinationFile(){
        String packageFolder = outputPackage.replace(".", "/");
        return new File(new File(outputSourcesRoot, packageFolder), "Assets.java");
    }

    @Input
    public String getResourcesDirName(){
        return resourcesDirName;
    }

    public void setResourcesDirName(String resourcesDirName){
        this.resourcesDirName = resourcesDirName;
    }

    public void setOutputSourcesRoot(File outputSourcesRoot){
        this.outputSourcesRoot = outputSourcesRoot;
    }

    public void setOutputPackage(String outputPackage){
        this.outputPackage = outputPackage;
    }

    public void setAssetsFolder(File assetsFolder){
        this.assetsFolder = assetsFolder;
    }


    private static class AssetsFolder{
        String assetFolderPath;

        Map<String, AssetsFolder> subfolders = new LinkedHashMap<>();

        List<String> assetsOnThisLevel = new ArrayList<>();

        public AssetsFolder(String assetFolderPath){
            this.assetFolderPath = assetFolderPath;
        }

        public String getJavaClassContent(int indentLevel){
            StringBuilder content = new StringBuilder();

            Set<String> usedSimpleNames = new HashSet<>();

            for(String asset : assetsOnThisLevel){
                String complexName = toUpperSnakeCase(makeValidJavaIdentifier(asset));
                String simpleName = toUpperSnakeCase(makeValidJavaIdentifier(asset.replaceAll("\\..*", "")));
                String nameToUse;
                if (!usedSimpleNames.contains(simpleName)){
                    nameToUse = simpleName;
                    usedSimpleNames.add(simpleName);
                }else{
                    nameToUse = complexName;
                }

                content
                        .append(" ".repeat(indentLevel*4))
                        .append("public static final String ").append(nameToUse)
                        .append(" = \"").append(assetFolderPath + "/"+asset).append("\";\n");
            }

            for(Map.Entry<String, AssetsFolder> subfolder : subfolders.entrySet()){
                content
                        .append(" ".repeat(indentLevel*4))
                        .append("public static class ").append(makeValidJavaClass(subfolder.getKey()))
                        .append("{\n")
                        .append(subfolder.getValue().getJavaClassContent(indentLevel+1))
                        .append(" ".repeat(indentLevel*4))
                        .append("}\n");
            }
            return content.toString();
        }

        public void addAsset(String asset){
            assetsOnThisLevel.add(asset);
        }

        public void addSubfolder(String subfolder, AssetsFolder assetsFolder){
            subfolders.put(subfolder, assetsFolder);
        }

        private String makeValidJavaClass(String name){
            String validIdentifier = makeValidJavaIdentifier(name);
            return validIdentifier.substring(0, 1).toUpperCase() + validIdentifier.substring(1);
        }

        private String makeValidJavaIdentifier(String name){
            String corrected = name.replaceAll("[^a-zA-Z0-9]", "_");

            if (Character.isDigit(corrected.charAt(0))){
                corrected = "_" + corrected;
            }
            return corrected;
        }

        private String toUpperSnakeCase(String name){
            return name.replaceAll("([a-z])([A-Z])", "$1_$2").toUpperCase();
        }
    }

}
