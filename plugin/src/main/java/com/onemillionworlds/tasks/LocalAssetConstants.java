package com.onemillionworlds.tasks;

import org.gradle.api.DefaultTask;
import org.gradle.api.Project;
import org.gradle.api.artifacts.Configuration;
import org.gradle.api.file.FileCollection;
import org.gradle.api.tasks.Input;
import org.gradle.api.tasks.InputFiles;
import org.gradle.api.tasks.OutputFile;
import org.gradle.api.tasks.Optional;
import org.gradle.api.tasks.SourceSet;
import org.gradle.api.tasks.SourceSetContainer;
import org.gradle.api.tasks.TaskAction;
import org.gradle.internal.impldep.com.google.common.base.Strings;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public class LocalAssetConstants extends DefaultTask{

    private static final String FLAT_FILE_CONTEXT_CHANGE = "::";
    private static final String ASSETS_FILE_NAME = "com.onemillionworlds.typedmaterials.assets.txt";

    private static final String classTemplate = """
                                     package [PACKAGE];
                                     
                                     /**
                                      * AUTOGENERATED CLASS, do not modify
                                      * <p>
                                      * Generated by the Typed Materials plugin. For more information:
                                      * </p>
                                      * @see <a href="https://github.com/oneMillionWorlds/TypedMaterials/wiki">MaterialTyper Plugin Wiki</a>
                                      */
                                     @SuppressWarnings("all")
                                     public class [CLASS] {
                                     
                                     [CONTENT]
                                     
                                     }""";

    /**
     * If present, use this as the class name for the Assets constants class
     */
    String fullyQualifiedAssetsClass;

    /**
     * If present use this as a regex to defermine if a jar should be fully searched for assets.
     * (This means going through every file in the jar, not using the flat file that helpful libraries may
     * leave in the jar)
     */
    String jarFilterRegex;

    /**
     * If present, use this sources root to output all the assets as a java class
     */
    File outputSourcesRoot;

    /**
     * If present, use this resources root to output all the assets as a flat file
     */
    File outputResourcesRoot;

    @TaskAction
    public void createTypedMaterials() throws IOException{
        AssetsFolder assetsFolder = new AssetsFolder("");

        for(File folder : getFileCollectionFromSourceDirs()){
            assetsFolder.addAll(searchForAllFiles(folder, "", null));
        }

        AssetsFolder resourcesFolderFast = searchAllFromResourceFlatFiles();
        assetsFolder.addAll(resourcesFolderFast);

        if(jarFilterRegex!=null && !jarFilterRegex.isBlank()){
            AssetsFolder jarAssets = searchAllFromJars(jarFilterRegex);
            assetsFolder.addAll(jarAssets);
        }

        try {
            if(getDestinationFile() != null){
                String classContent = assetsFolder.getJavaClassContent(1, List.of(getClassName()));

                String fullClass = classTemplate
                        .replace("[PACKAGE]", getDestinationPackage())
                        .replace("[CLASS]", getClassName())
                        .replace("[CONTENT]", classContent);
                Files.writeString(getDestinationFile().toPath(), fullClass);
            }
            if(getDestinationFlatFile()!=null){
                String flatFileStringBuilder = FLAT_FILE_CONTEXT_CHANGE+getProject().getName() + "/n" +
                        assetsFolder.getFileListingContent();
                Files.writeString(getDestinationFlatFile().toPath(), flatFileStringBuilder);
            }
        } catch (Exception e) {
            throw new RuntimeException("Error writing record of generation: " + getName() + ". " + e.getMessage(), e);
        }
    }

    private AssetsFolder searchAllFromJars(String jarFilterRegex){
        Pattern pattern = Pattern.compile(jarFilterRegex);
        Pattern patternEverythingAfterResources = Pattern.compile(".*/resources/(.*)");
        Configuration test = getProject().getConfigurations().getByName("runtimeClasspath");
        Set<File> resolve = test.resolve();

        AssetsFolder assetsFolder = new AssetsFolder("");

        resolve.forEach(file -> {
            if (file.getName().endsWith(".jar") && pattern.matcher(file.getName()).matches()) {
                String context = file.getName().replace(".jar", "");

                try (ZipInputStream zip = new ZipInputStream(new FileInputStream(file))) {
                    ZipEntry entry;
                    while ((entry = zip.getNextEntry()) != null) {
                        if (entry.getName().contains("/resources/")) {
                            Matcher matcher = patternEverythingAfterResources.matcher(entry.getName());
                            if(matcher.matches()){
                                String path = matcher.group(1);
                                assetsFolder.addAssetFromFullRelativePath(path, context);
                            }
                        }
                        zip.closeEntry();
                    }
                } catch (Exception e) {
                    throw new RuntimeException("Error processing JAR: " + file + e.getMessage(), e);
                }
            }
        });
        return assetsFolder;
    }

    private AssetsFolder searchForAllFiles(File file, String currentPath, String context) throws IOException{

        AssetsFolder assetsFolder = new AssetsFolder(currentPath);

        for( File fileToProcess : Arrays.stream(file.listFiles()).sorted().toList()){
            if (fileToProcess.isFile()){
                assetsFolder.addAsset(new AssetItem(fileToProcess.getName(), context));
            }else{
                AssetsFolder subFolder = searchForAllFiles(fileToProcess, currentPath + (currentPath.isBlank()?"":"/") + fileToProcess.getName(), context);
                assetsFolder.addSubfolder(fileToProcess.getName(), subFolder);
            }
        }

        return assetsFolder;
    }

    private AssetsFolder searchAllFromResourceFlatFiles(){
        AssetsFolder assetsFolder = new AssetsFolder("");

        List<String> allLibraryAssetFiles = loadAllLibraryAssetFiles();
        String context = null;
        for(String asset : allLibraryAssetFiles){
            if(asset.startsWith(FLAT_FILE_CONTEXT_CHANGE)){
                context = asset.substring(FLAT_FILE_CONTEXT_CHANGE.length());
                continue;
            }
            assetsFolder.addAssetFromFullRelativePath(asset, context);
        }

        return assetsFolder;
    }

    @Optional
    @Input
    public String getFullyQualifiedAssetsClass(){
        return fullyQualifiedAssetsClass;
    }

    /*
    @InputFiles
    public Collection<File> getFoldersToProcess(){
        SourceSetContainer sourceSets = (SourceSetContainer) getProject().getProperties().get("sourceSets");
        SourceSet mainSourceSet = sourceSets.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
        return mainSourceSet.getResources().getSrcDirs();
    }*/

    @InputFiles
    public FileCollection getFileCollectionFromSourceDirs() {
        Project project = getProject();
        SourceSetContainer sourceSets = (SourceSetContainer) project.getProperties().get("sourceSets");
        SourceSet mainSourceSet = sourceSets.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
        return project.files(mainSourceSet.getResources().getSrcDirs());
    }

    @Optional
    @OutputFile
    public File getDestinationFile(){
        if(outputSourcesRoot == null || fullyQualifiedAssetsClass == null){
            return null;
        }
        return new File(outputSourcesRoot, fullyQualifiedAssetsClass.replace(".", "/") + ".java");
    }

    @Optional
    @OutputFile
    public File getDestinationFlatFile(){
        if(outputResourcesRoot == null){
            return null;
        }
        return new File(outputResourcesRoot, ASSETS_FILE_NAME);
    }

    public void setOutputSourcesRoot(File outputSourcesRoot){
        this.outputSourcesRoot = outputSourcesRoot;
    }

    public void setOutputResourcesRoot(File outputResourcesRoot){
        this.outputResourcesRoot = outputResourcesRoot;
    }

    public void setFullyQualifiedAssetsClass(String fullyQualifiedAssetsClass){
        this.fullyQualifiedAssetsClass = fullyQualifiedAssetsClass;
    }

    private String getDestinationPackage(){
        return fullyQualifiedAssetsClass
                .replaceAll("\\.[A-Za-z0-9_]+$", "");
    }

    private String getClassName(){
        return fullyQualifiedAssetsClass
                .replaceAll(".*\\.", "");
    }

    private List<String> loadAllLibraryAssetFiles(){
        ClassLoader classLoader = LocalAssetConstants.class.getClassLoader();

        List<String> content = new ArrayList<>();
        try {
            Enumeration<URL> resources = classLoader.getResources(ASSETS_FILE_NAME);
            while (resources.hasMoreElements()) {
                URL resourceUrl = resources.nextElement();
                System.out.println("Found resource at: " + resourceUrl);

                try (InputStream inputStream = resourceUrl.openStream();
                     BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {

                    String line;
                    while ((line = reader.readLine()) != null) {
                        content.add(line);
                    }
                }
            }
        } catch (IOException e) {
            throw new RuntimeException("Error reading assets file: " + e.getMessage(), e);
        }
        return content;
    }

    private static class AssetsFolder{
        String assetFolderPath;

        Map<String, AssetsFolder> subfolders = new LinkedHashMap<>();

        List<AssetItem> assetsOnThisLevel = new ArrayList<>();

        public AssetsFolder(String assetFolderPath){
            this.assetFolderPath = assetFolderPath;
        }

        public String getJavaClassContent(int indentLevel, List<String> parentFolders){
            StringBuilder content = new StringBuilder();

            Set<String> usedSimpleNames = new HashSet<>();

            if(indentLevel>1){
                content
                        .append(" ".repeat(indentLevel * 4))
                        .append("public static final String FOLDER_PATH")
                        .append(" = \"").append(assetFolderPath).append("\";\n");
                usedSimpleNames.add("FOLDER_PATH");
            }
            for(AssetItem asset : assetsOnThisLevel){
                String complexName = toUpperSnakeCase(makeValidJavaIdentifier(asset.name));
                String simpleName = toUpperSnakeCase(makeValidJavaIdentifier(asset.name.replaceAll("\\..*", "")));
                String nameToUse;
                if (!usedSimpleNames.contains(simpleName)){
                    nameToUse = simpleName;
                    usedSimpleNames.add(simpleName);
                }else{
                    nameToUse = complexName;
                }

                content
                        .append(" ".repeat(indentLevel*4))
                        .append("public static final String ").append(nameToUse)
                        .append(" = \"").append(assetFolderPath + "/"+asset.name).append("\";\n");
            }

            if(indentLevel>1){
                content.append("\n")
                        .append(" ".repeat(indentLevel * 4)).append("public static String child(String child){\n")
                        .append(" ".repeat(indentLevel * 4)).append("    return FOLDER_PATH + \"/\" + child;\n")
                        .append(" ".repeat(indentLevel * 4)).append("}\n");
            }

            for(Map.Entry<String, AssetsFolder> subfolder : subfolders.entrySet()){
                List<String> parentFoldersForChild = new ArrayList<>(parentFolders);
                parentFoldersForChild.add(subfolder.getKey());
                content
                        .append(" ".repeat(indentLevel*4))
                        .append("public static class ").append(makeValidJavaClass(subfolder.getKey(), parentFolders))
                        .append("{\n")
                        .append(subfolder.getValue().getJavaClassContent(indentLevel+1, parentFoldersForChild))
                        .append(" ".repeat(indentLevel*4))
                        .append("}\n");
            }

            return content.toString();
        }

        /**
         * This is just a list of all the files, which is put into the resources folder to be pickd up in other modules
         * (if desired) to create a single super assets class
         */
        public StringBuilder getFileListingContent(){
            StringBuilder content = new StringBuilder();
            for(AssetItem assetOnThisLevel : assetsOnThisLevel){
                content.append(assetFolderPath).append("/").append(assetOnThisLevel.name).append("\n");
            }
            for(AssetsFolder subfolder : subfolders.values()){
                content.append(subfolder.getFileListingContent());
            }
            return content;
        }

        public void addAsset(AssetItem asset){
            assetsOnThisLevel.add(asset);
        }

        public void addAssetFromFullRelativePath(String fullRelativePath, String context){
            if(assetFolderPath.contains("/")){
                String subfolder = fullRelativePath.substring(0, fullRelativePath.indexOf("/"));
                String assetName = fullRelativePath.substring(fullRelativePath.indexOf("/")+1);
                if(subfolders.containsKey(subfolder)){
                    subfolders.get(subfolder).addAsset(new AssetItem(assetName, context));
                }else{
                    AssetsFolder newFolder = new AssetsFolder(assetName);
                    newFolder.addAsset(new AssetItem(assetName, context));
                    subfolders.put(subfolder, newFolder);
                }
            }else {
                addAsset(new AssetItem(assetFolderPath, context));
            }
        }

        public void addSubfolder(String subfolder, AssetsFolder assetsFolder){
            subfolders.put(subfolder, assetsFolder);
        }

        private String makeValidJavaClass(String name, List<String> parentFolders){
            String validIdentifier = makeValidJavaIdentifier(name);
            int numberOfParentsWithSameName = (int) parentFolders.stream()
                    .map(this::makeValidJavaIdentifier)
                    .filter(folder -> folder.equals(validIdentifier)).count();
            String numericSuffix = numberOfParentsWithSameName == 0 ? "" : "_"+(numberOfParentsWithSameName+1);

            String validIdentifierWithSuffix = makeValidJavaIdentifier(name) + numericSuffix;
            return validIdentifierWithSuffix.substring(0, 1).toUpperCase() + validIdentifierWithSuffix.substring(1);
        }

        private String makeValidJavaIdentifier(String name){
            String corrected = name.replaceAll("[^a-zA-Z0-9]", "_");

            if (Character.isDigit(corrected.charAt(0))){
                corrected = "_" + corrected;
            }
            return corrected;
        }

        private String toUpperSnakeCase(String name){
            return name.replaceAll("([a-z])([A-Z])", "$1_$2").toUpperCase();
        }

        public void addAll(AssetsFolder assetsFolder){
            assetsOnThisLevel.addAll(assetsFolder.assetsOnThisLevel);
            for(Map.Entry<String, AssetsFolder> subfolder : assetsFolder.subfolders.entrySet()){
                if (subfolders.containsKey(subfolder.getKey())){
                    subfolders.get(subfolder.getKey()).addAll(subfolder.getValue());
                }else{
                    subfolders.put(subfolder.getKey(), subfolder.getValue());
                }
            }
        }
    }

    private static class AssetItem{
        /**
         * This is which library it came from, used only in a comment. Can be null, in which case it is not included
         */
        String context;
        String name;

        public AssetItem(String name, String context){
            this.context = context;
            this.name = name;
        }
    }

}
